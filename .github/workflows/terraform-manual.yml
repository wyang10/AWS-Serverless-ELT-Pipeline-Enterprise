name: terraform-manual

on:
  workflow_dispatch:
    inputs:
      auth:
        description: "AWS auth method"
        required: true
        default: keys
        type: choice
        options:
          - keys
          - oidc
      action:
        description: "What to run"
        required: true
        default: plan
        type: choice
        options:
          - plan
          - apply
          - destroy
      tf_dir:
        description: "Terraform environment directory"
        required: true
        default: infra/terraform/envs/dev
        type: string
      tf_var_file:
        description: "Terraform var-file (relative to tf_dir)"
        required: true
        default: dev.tfvars
        type: string
      confirm:
        description: "Type APPLY or DESTROY to confirm destructive actions"
        required: false
        default: ""
        type: string

jobs:
  terraform:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          # Disable the wrapper to preserve Terraform's real exit codes and output.
          terraform_wrapper: false

      - name: Preflight AWS credentials
        run: |
          set -euo pipefail
          echo "auth=${{ inputs.auth }}"

          if [ "${{ inputs.auth }}" = "oidc" ]; then
            if [ -z "${AWS_ROLE_TO_ASSUME:-}" ]; then
              echo "::error::Missing secret AWS_ROLE_TO_ASSUME. Add it in Settings -> Secrets and variables -> Actions."
              exit 1
            fi
            echo "OK: AWS_ROLE_TO_ASSUME is set."
            exit 0
          fi

          if [ -z "${AWS_ACCESS_KEY_ID:-}" ] || [ -z "${AWS_SECRET_ACCESS_KEY:-}" ]; then
            echo "::error::Missing AWS access key secrets. Add AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY in Settings -> Secrets and variables -> Actions."
            echo "::error::If you are using SSO, create an access key for an IAM user (or use auth=oidc)."
            exit 1
          fi

          echo "OK: AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY are set."
        env:
          AWS_ROLE_TO_ASSUME: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Configure AWS credentials (OIDC)
        if: ${{ inputs.auth == 'oidc' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: us-east-2

      - name: Configure AWS credentials (access keys)
        if: ${{ inputs.auth == 'keys' }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-2

      - name: Build lambda artifacts (required for plan/apply)
        run: |
          python -m pip install --upgrade pip
          make build

      - name: Prepare remote backend config (optional)
        id: backend
        run: |
          set -euo pipefail
          if [ -n "${TF_BACKEND_HCL:-}" ]; then
            echo "$TF_BACKEND_HCL" > "${{ inputs.tf_dir }}/_backend.hcl"
            echo "backend_file=${{ inputs.tf_dir }}/_backend.hcl" >> "$GITHUB_OUTPUT"
          fi
        env:
          TF_BACKEND_HCL: ${{ secrets.TF_BACKEND_HCL }}

      - name: Terraform init
        run: |
          set -euo pipefail
          if [ -n "${{ steps.backend.outputs.backend_file }}" ]; then
            terraform -chdir="${{ inputs.tf_dir }}" init -backend-config="${{ steps.backend.outputs.backend_file }}"
          else
            echo "::warning::TF_BACKEND_HCL not set; using local backend in runner (plan is still useful, apply/destroy is blocked)."
            terraform -chdir="${{ inputs.tf_dir }}" init
          fi

      - name: Terraform plan
        if: ${{ inputs.action == 'plan' }}
        run: |
          set +e
          terraform -chdir="${{ inputs.tf_dir }}" plan -no-color -var-file="${{ inputs.tf_var_file }}"
          rc=$?
          # Some setups inject -detailed-exitcode via TF_CLI_ARGS_plan; treat "changes present" as success.
          if [ "$rc" -eq 2 ]; then
            echo "Terraform plan has changes (exit code 2)."
            exit 0
          fi
          exit "$rc"

      - name: Terraform apply (requires TF_BACKEND_HCL + confirm=APPLY)
        if: ${{ inputs.action == 'apply' }}
        run: |
          set -euo pipefail
          if [ "${{ inputs.confirm }}" != "APPLY" ]; then
            echo "Refusing to apply. Re-run with confirm=APPLY."
            exit 1
          fi
          if [ -z "${{ steps.backend.outputs.backend_file }}" ]; then
            echo "Refusing to apply with local backend in runner. Set secret TF_BACKEND_HCL for remote state."
            exit 1
          fi
          terraform -chdir="${{ inputs.tf_dir }}" apply -auto-approve -var-file="${{ inputs.tf_var_file }}"

      - name: Terraform destroy (requires TF_BACKEND_HCL + confirm=DESTROY)
        if: ${{ inputs.action == 'destroy' }}
        run: |
          set -euo pipefail
          if [ "${{ inputs.confirm }}" != "DESTROY" ]; then
            echo "Refusing to destroy. Re-run with confirm=DESTROY."
            exit 1
          fi
          if [ -z "${{ steps.backend.outputs.backend_file }}" ]; then
            echo "Refusing to destroy with local backend in runner. Set secret TF_BACKEND_HCL for remote state."
            exit 1
          fi
          terraform -chdir="${{ inputs.tf_dir }}" destroy -auto-approve -var-file="${{ inputs.tf_var_file }}"
